# 🧠 核心概念

理解 Quipu 的核心在于理解它是如何解析指令以及如何管理状态的。

## 1. 协议：Act 与 Context

Quipu 将操作分解为两个原语：

*   **Act (动词)**: 定义要做什么（例如：写入文件、提交代码）。
*   **Context (名词)**: 提供操作所需的参数（例如：文件路径、代码内容）。

这种结构天然契合 Markdown 的代码块语法：

````markdown
~~~act
write_file      <-- Act
~~~
~~~path
main.py         <-- Context 1
~~~
~~~content
print("Hi")     <-- Context 2
~~~
````

## 2. 参数解析模式 (ArgMode)

为了平衡灵活性与严谨性，不同的 Act 使用不同的参数解析策略：

| 模式 | 描述 | 适用指令示例 |
| :--- | :--- | :--- |
| **Hybrid (混合模式)** | **贪婪合并**。既读取 `act` 行内的参数，也读取后续的代码块。 | `write_file`, `replace` |
| **Exclusive (互斥模式)** | **优先行内**。如果行内有参数，则忽略后续代码块；否则读取代码块。 | `git_add`, `run_command` |
| **Block Only (仅块模式)** | **严格模式**。强制忽略行内参数，只读取代码块。常用于防止 AI 乱写参数。 | `git_commit` |

## 3. 智能幕布 (Smart Parsers)

Quipu 支持多种围栏符号，以便在文档中嵌套代码块时互不干扰：

*   **绿幕模式**：使用 ` ```act `。适用于普通文本指令。
*   **蓝幕模式**：使用 ` ~~~act `。适用于指令内容中包含反引号（如 Python 代码）的情况。
*   **变长围栏**：支持 `~~~~~act` 或 ` `````act `，只要围栏长度大于等于 3 且首尾匹配即可。

## 4. 幽灵状态引擎 (Phantom State Engine)

Quipu 引入了革命性的状态管理机制，它基于 Git 底层对象模型，而非传统的文件数据库。

*   **状态即真理 (State is Truth)**: Quipu 不维护任何状态数据库。它通过实时计算当前工作区所有文件的 **Git Tree Hash** 来唯一确定当前所处的状态。这从根本上杜绝了状态不同步的问题。

*   **惰性捕获 (Lazy Capture)**: 在执行新指令前，如果 Quipu 发现当前工作区的状态与历史记录不符（例如，你手动修改了代码），它会自动触发一次“捕获”，生成一个 **Capture Node** 来保存你未记录的变更。这意味着你的工作永远不会被覆盖或丢失。

*   **事件时间轴 (Event-based Timeline)**: Quipu (v0.3.0+) 引入了事件流机制，即使一个操作没有修改任何文件（如 `git commit` 或运行测试），它也会被记录为一个**幂等节点 (Idempotent Node)**。这确保了 Quipu 的历史是一条完整的、可审计的**事件流**，而不仅仅是文件快照。

*   **历史即图谱 (History as a DAG)**: Quipu 的历史记录不是一条直线，而是一个**有向无环图 (DAG)**。当你 `checkout` 到一个旧节点并执行新的 Plan 时，就会自然地创建出一个新的分支。这使得无损实验和多方案探索成为可能，也是 `undo`, `redo`, `prev`, `next` 等导航命令的基础。---

## 持久化本地忽略规则：保护你的开发环境

### 问题：为什么我的本地文件在 `checkout` 后消失了？

你可能遇到过这样的情况：在使用 `quipu checkout` 或 `quipu discard` 切换到一个旧的状态后，一些不属于项目代码的文件，比如你的 Python 虚拟环境目录 (`.envs/`)、IDE 配置文件 (`.idea/`) 或临时的笔记文件 (`o.md`)，突然不见了。

这并不是一个 Bug，而是一个由 Git 工作机制导致的副作用。原因如下：
1.  **`checkout` 还原的是完整的项目状态**：这包括项目中的所有文件，也包括 `.gitignore` 文件本身。
2.  **`.gitignore` 文件是会变化的**：你当前版本的 `.gitignore` 可能配置了忽略 `.envs/`，但你检出的旧版本可能没有这条规则。
3.  **`git clean` 的作用**：为了确保工作区的纯净，Quipu 在 `checkout` 后会使用 `git clean` 命令来移除所有不属于目标状态、也**未被**当前 `.gitignore` 忽略的文件。

因此，当你切换到一个没有忽略 `.envs/` 规则的旧状态时，`git clean` 会认为 `.envs/` 是一个应该被清理的“多余”目录，并将其删除。

### 解决方案：分离“项目忽略”与“本地忽略”

为了解决这个问题，Quipu 引入了一套基于 Git 标准功能的持久化本地忽略机制。我们认为，忽略规则应该分为两类：

*   **项目级忽略 (`.gitignore`)**: 这些规则是项目的一部分，应该被所有协作者共享，并随项目历史一起变化。例如，`__pycache__/` 或 `build/` 目录。
*   **本地级忽略 (`.git/info/exclude`)**: 这些规则属于开发者个人的本地配置，不应该被提交或共享。例如，你个人的虚拟环境目录、IDE 配置文件或私人笔记。

Quipu 会自动将你的本地级忽略规则写入到 `.git/info/exclude` 文件中。这个文件中的规则优先级很高，并且独立于任何历史提交，因此无论你 `checkout` 到哪个版本，这些规则都会始终生效，从而保护你的本地文件不被误删。

### 如何使用？

**1. 默认配置 (自动保护)**

开箱即用，Quipu 已经为你提供了一组默认的持久化忽略规则。在每次运行时，Quipu 都会确保以下模式被添加到 `.git/info/exclude` 中：

```
.idea
.vscode
.envs
__pycache__
node_modules
o.md
```

对于大多数用户来说，你无需进行任何操作，你的开发环境就已经受到了保护。

**2. 自定义规则**

如果你有额外的文件或目录需要被持久化忽略，你可以通过在项目根目录下的 `.quipu/config.yml` 文件中进行配置来扩展默认规则。

例如，假设你习惯在项目根目录创建一个 `temp_notes.txt` 来存放临时笔记，你可以这样配置：

1.  创建或打开 `.quipu/config.yml` 文件。
2.  添加 `sync.persistent_ignores` 列表，并写入你自己的规则：

    ```yaml
    sync:
      # 这里的列表会覆盖默认配置，所以请将默认配置中你需要的部分也一并保留
      persistent_ignores:
        - ".idea"
        - ".vscode"
        - ".envs"
        - "__pycache__"
        - "node_modules"
        - "o.md"
        # --- 在下方添加你的自定义规则 ---
        - "temp_notes.txt"
        - "*.backup"
    ```

完成配置后，下次运行任何 `quipu` 命令时，这些新规则就会被自动同步到 `.git/info/exclude` 文件中，为你提供持久化的保护。